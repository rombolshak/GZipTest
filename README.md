# Задание
Разработать консольное приложение на C# для поблочного сжатия и распаковки файлов с помощью System.IO.Compression.GzipStream.

Для сжатия исходный файл делится на блоки одинакового размера, например, в 1 мегабайт. Каждый блок сжимается и записывается в выходной файл независимо от остальных блоков.

Программа должна эффективно распараллеливать и синхронизировать обработку блоков в многопроцессорной среде и уметь обрабатывать файлы, размер которых превышает объем доступной оперативной памяти.

В случае исключительных ситуаций необходимо проинформировать пользователя понятным сообщением, позволяющим пользователю исправить возникшую проблему, в частности, если проблемы связаны с ограничениями операционной системы.

При работе с потоками допускается использовать только базовые классы и объекты синхронизации (Thread, Manual/AutoResetEvent, Monitor, Semaphor, Mutex) и не допускается использовать async/await, ThreadPool, BackgroundWorker, TPL.

Код программы должен соответствовать принципам ООП и ООД (читаемость, разбиение на классы и
т.д.).

Параметры программы, имена исходного и результирующего файлов должны задаваться в
командной строке следующим образом:
    `GZipTest.exe [compress|decompress] [имя исходного файла] [имя результирующего файла]`

В случае успеха программа должна возвращать 0, при ошибке возвращать 1.
Примечание: формат архива остаётся на усмотрение автора, и не имеет значения для оценки качества
тестового, в частности соответствие формату GZIP опционально.

# Сборка
Проект написан под .NET Core 2.0, для сборки необходимо выполнить:
`dotnet build -c Release`

# Запуск
В случае, если запуск производится на Win10-x64, достаточно запустить
`bin\Release\netcoreapp2.0\win-x64\GZipTest.exe <arguments>`

В противном случае можно либо воспользоваться командой ` dotnet run --project .\GZipTest\ <arguments>`, либо добавить конфигурацию машины в блок `RuntimeIdentifier` файла проекта, пересобраться, и запустить exe из соответствующей папки.

# Описание реализации
Программа состоит из набора агентов. Разбиение на агенты было произведено с целью улучшения тестирования.
Агенты:
- Считывающий входной файл
- Записывающий выходной файл
- Проводящий сжатие
- Проводящий разжатие

Агенты коммуницируют друг с другом через *Pipe*. Данный объект контролирует количество проходящих через него сообщений, блокируя укладку нового на входной стороне, если агент на выходной стороне не успевает сообщения вычитывать. Таким образом обеспечивается максимальная загрузка наиболее медленного компонента при константном потреблении памяти.

Агенты, работающие с файлами, запускаются в единственном экземпляре. Агенты, производящие сжатие\разжатие, запускаются в количестве, равным количеству процессорных ядер, и обрабатывают части входного файла параллельно.

Входной файл читается блоками в 1МБ, каждый блок нумеруется и отправляется в *Pipe*.
Из *Pipe* блок забирает один из параллельных агентов, обрабатывает его и отправляет во второй *Pipe*.
Из второго *Pipe* производит чтение агент записи выходного файла. Поскольку блоки могут приходить не в том порядке, в каком должны быть записаны, этот агент производит дополнительное упорядочивание блоков, для чего заводится временное хранилище блоков, пришедших невовремя. Тем не менее, размер этого хранилища по построению алгоритма не превышает числа обрабатывающих агентов + константа.

Параметры программы проходят валидацию. В случае провала выводится соответствующее сообщение об ошибке.
В случае успеха создается экземпляр *TaskProcessor*, подготавливающий файлы и агентов к работе. Он же производит дополнительную валидацию обрабатываемых файлов. 

Если всё в порядке, создается и запускается экземпляр *Task*, хранящий в себе состояния всех запущенных на данный момент агентов и имеющий возможность прервать выполнение операции.
По завершению задачи фиксируется длительность выполнения и наличие ошибок.
